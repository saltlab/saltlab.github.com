@INPROCEEDINGS{bozdag:wse2007,
  author = {Engin Bozdag and Ali Mesbah and van Deursen, Arie},
  title = {A Comparison of Push and Pull Techniques for Ajax},
  booktitle = {Proceedings of the International Symposium on Web Site Evolution (WSE)},
  year = {2007},
  pages = {15--22},
  publisher = {IEEE Computer Society},
}

@ARTICLE{bozdag:jwe,
  author = {Engin Bozdag and Ali Mesbah and van Deursen, Arie},
  title = {Performance Testing of Data Delivery Techniques for Ajax Applications},
  journal = {Journal of Web Engineering},
  year = {2009},
  volume	= {8},
  number	= {4},
  pages	= {287--315},
  url={http://swerl.tudelft.nl/twiki/pub/Main/TechnicalReports/TUD-SERG-2008-009.pdf}
}

@INPROCEEDINGS{gharavi:iwwost08,
  author = {Vahid Gharavi and Ali Mesbah and van Deursen, Arie},
  title = {Modelling and Generating Ajax Applications: A Model-Driven Approach},
  booktitle = {Proceedings of the 7th ICWE International Workshop on Web-Oriented
	Software Technologies (IWWOST'08)},
  year = {2008},
  pages = {38-43},  
}

@INPROCEEDINGS{mesbah:icse07,
  author = {Ali Mesbah},
  title = {Ajaxifying Classic Web Applications},
  booktitle = {Proceedings of the International Conference on Software Engineering, Doctoral Symposium (ICSE)},
  year = {2007},
  pages = {81--82},
  publisher = {IEEE Computer Society},
  url = {http://dx.doi.org/10.1109/ICSECOMPANION.2007.19},
}

@INPROCEEDINGS{mesbah:migrate07,
  author = {Ali Mesbah and van Deursen, Arie},
  title = {Migrating Multi-page Web Applications to Single-page Ajax Interfaces},
  booktitle = {Proceedings of the Conference on Software Maintenance and Reengineering (CSMR)},
  year = {2007},
  pages = {181--190},
  publisher = {IEEE Computer Society}
}

@INPROCEEDINGS{mesbah:wicsa07,
  author = {Ali Mesbah and van Deursen, Arie},
  title = {An Architectural Style for Ajax},
  booktitle = {Proceedings of the 6th Working Conference on Software Architecture
	(WICSA)},
  year = {2007},
  pages = {44--53},
  publisher = {IEEE Computer Society}
}

@INPROCEEDINGS{mesbah:ccc,
  author = {Ali Mesbah and van Deursen, Arie},
  title = {Crosscutting Concerns in J2EE Applications},
  booktitle = {Proceedings of the International Symposium on Web Site Evolution	(WSE)},
  year = {2005},
  pages = {14--21},
  publisher = {IEEE Computer Society},
  url = {http://dx.doi.org/10.1109/WSE.2005.4},
}

@INPROCEEDINGS{mesbah:icwe08,
  author = {Ali Mesbah and Engin Bozdag and van Deursen, Arie},
  title = {Crawling Ajax by Inferring User Interface State Changes},
  booktitle = {Proceedings of the International Conference on Web Engineering (ICWE)},
  year = {2008},
  pages = {122--134},
  publisher = {IEEE Computer Society},
  url = {http://www.ece.ubc.ca/~amesbah/docs/icwe08.pdf}
}

@INPROCEEDINGS{mesbah:icse09,
  author = {Ali Mesbah and Arie van Deursen},
  title = {Invariant-Based Automatic Testing of Ajax User Interfaces},
  booktitle = {Proceedings of the 31st ACM/IEEE International Conference on Software Engineering (ICSE)},
  year = {2009},
  pages = {210--220},
  publisher = {IEEE Computer Society},
  url = {http://www.ece.ubc.ca/~amesbah/docs/icse09.pdf},
  note = {[Acceptance rate 12\%]},
  award= {[ACM SIGSOFT Distinguished Paper Award]}
}

@ARTICLE{mesbah:jss08,
  author = {Ali Mesbah and van Deursen, Arie},
  title = {A Component- and Push-based Architectural Style for Ajax Applications},
  journal = {Journal of Systems and Software (JSS)},
  year = {2008},
  volume = {81},
  pages = {2194--2209},
  number = {12},
  url = {http://salt.ece.ubc.ca/publications/docs/jss08.pdf}
}

@INPROCEEDINGS{bezemer:esec09,
  author = {Cor-Paul Bezemer and Ali Mesbah and van Deursen, Arie},
  title = {Automated Security Testing of Web Widget Interactions},
  booktitle = {Proceedings of the joint meeting of the European Software Engineering Conference and the ACM SIGSOFT symposium on the Foundations of Software Engineering (ESEC-FSE)},
  year = {2009},
  pages = {81--91},
  publisher = {ACM},
  url = {http://www.ece.ubc.ca/~amesbah/docs/fse09.pdf},
  note = {[Acceptance rate 14.7%]}
}

@INPROCEEDINGS{deursen:sofsem,
  author = {van Deursen, Arie and Ali Mesbah},
  title = {Research Issues in the Automated Testing
of Ajax Applications},
  booktitle = {Proceedings of the 36th International Conference on Current Trends in Theory and Practice of Computer Science (SOFSEM)},
  year = {2010},
  pages = {16--28},
  publisher = {Lecture Notes in Computer Science 5901, Springer-Verlag},
}

@InProceedings{Roest:2010.icst,
  author = 	 {Danny Roest and Ali Mesbah and van Deursen, Arie},
  title = 	 {Regression Testing Ajax Applications: Coping with Dynamism},
  booktitle = {Proceedings of the International Conference on Software Testing, Verification, and Validation (ICST)},
  year = 	 {2010},
  publisher = {IEEE Computer Society},
  pages = {128--136},
  url = {http://salt.ece.ubc.ca/publications/docs/icst10.pdf},
}

@ARTICLE{mesbah:tse12,
  author = {Ali Mesbah and van Deursen, Arie and Danny Roest},
  title = {Invariant-based Automatic Testing of Modern Web Applications},
  journal = {IEEE Transactions on Software Engineering (TSE)},
  year = {2012},
  volume={38}, 
  number={1}, 
  pages={35--53},
  url = {http://www.ece.ubc.ca/~amesbah/docs/tse11.pdf}
}

@inproceedings{VanDeursen:2010.nier,
	author	= {van Deursen, Arie and Ali Mesbah and Bas Cornelissen and Andy Zaidman and Martin Pinzger and Anja Guzzi},
	title	= {Adinda: A knowledgeable, Browser-Based IDE},
	booktitle	= {Proceedings of the International Conference on Software Engineering, New Ideas and Emerging Results Track (ICSE NIER)},
	publisher	= {ACM},
	year	= {2010},
	pages	= {203--206},
}

@inproceedings{mesbah:icse11,
	author = {Mesbah, Ali and Mukul R. Prasad},
	title = {Automated Cross-Browser Compatibility Testing},
	booktitle = {Proceedings of the ACM/IEEE International Conference on Software Engineering (ICSE)},
	year = {2011},
	pages = {561--570},
	publisher = {ACM},
	url = {http://www.ece.ubc.ca/~amesbah/docs/icse11.pdf},
	slides = {https://speakerdeck.com/saltlab/automated-cross-browser-computability-testing},
	abstract = {With the advent of Web 2.0 applications and new browsers, the cross-browser compatibility issue is becoming increasingly important. Although the problem is widely recognized among web developers, no systematic approach to tackle it exists today. None of the current tools, which provide screenshots or emulation environments, specifies any notion of cross-browser compatibility, much less check it automatically. In this paper, we pose the problem of cross-browser compatibility testing of modern web applications as a `functional consistency' check of web application behavior across different web browsers and present an automated solution for it. Our approach consists of (1) automatically analyzing the given web application under different browser environments and capturing the behavior as a finite-state machine; (2) formally comparing the generated models for equivalence on a pairwise-basis and exposing any observed discrepancies. We validate our approach on several open-source and industrial case studies to demonstrate its effectiveness and real-world relevance.}
}

@ARTICLE{mesbah:tweb12,
  author = {Ali Mesbah and van Deursen, Arie and Stefan Lenselink},
  title = {Crawling Ajax-based Web Applications through Dynamic Analysis of User Interface State Changes},
  journal = {ACM Transactions on the Web (TWEB)},
  year = {2012},
  volume = {6},
  number = {1},
  pages = {3:1--3:30},
  url = {http://www.ece.ubc.ca/~amesbah/docs/tweb-final.pdf}
}

@inproceedings{ocariza:icst12,
  title={AutoFLox: An Automatic Fault Localizer for Client-Side JavaScript},
  author={Frolin Jr Ocariza and Pattabiraman, Karthik and Mesbah, Ali},
  booktitle = {Proceedings of the International Conference on Software Testing, Verification and Validation (ICST)},
  year = {2012},
  pages = {31--40},
  publisher = {IEEE Computer Society},
  url = {http://www.ece.ubc.ca/~amesbah/docs/icst12.pdf}
}

@inproceedings{mesbah:icse2012,
	author = {Ali Mesbah and Shabnam Mirshokraie},
	title = {Automated Analysis of CSS Rules to Support Style Maintenance},
	booktitle = {Proceedings of the ACM/IEEE International Conference on Software Engineering (ICSE)},
	year = {2012},
  pages = {408--418},
	publisher = {IEEE Computer Society},
	url = {http://www.ece.ubc.ca/~amesbah/docs/icse12.pdf},
	slides = {40727471},
	abstract = {CSS is a widely used language for describing the presentation semantics of HTML elements on the web. The language has a number of characteristics, such as inheritance and cascading order, which makes maintaining CSS code a challenging task for web developers. As a result, it is common for unused rules to be accumulated over time. Despite these challenges, CSS analysis has not received much attention from the research community. We propose an automated technique to support styling code maintenance, which (1) analyzes the
runtime relationship between the CSS rules and DOM elements of a given web application (2) detects unmatched and ineffective selectors, overridden declaration properties, and unde?ned
class values. Our technique, implemented in an open source tool called CILLA, has a high precision and recall rate. The results of our case study, conducted on fifteen open source and
industrial web-based systems, show an average of 60 precent unused CSS selectors in deployed applications, which points to the ubiquity of the problem.}
}

@inproceedings{shabnam:icwe12,
	author = {Shabnam Mirshokraie and Ali Mesbah},
	title = {JSART: JavaScript Assertion-based Regression Testing},
	booktitle = {Proceedings of the International Conference on Web Engineering (ICWE)},
	year = {2012}, 
  pages = {238--252},
	publisher = {Springer},
	url = {http://www.ece.ubc.ca/~amesbah/docs/icwe12.pdf},
  note = {[Acceptance rate 20%]}
}

@inproceedings{mona:wcre12,
	author = {Erfani Joorabchi, Mona and Ali Mesbah},
	title = {Reverse Engineering iOS Mobile Applications},
	booktitle = {Proceedings of the Working Conference on Reverse Engineering (WCRE)},
	year = {2012}, 
	publisher = {IEEE Computer Society},
	pages = {177--186},
	url = {http://ece.ubc.ca/~amesbah/docs/wcre12.pdf}
}



@ARTICLE{garousi:ist13,
  author = {Vahid Garousi and Ali Mesbah and Betin Can, A. and Shabnam Mirshokraie},
  title = {A Systematic Mapping Study of Web Application Testing},
  journal   = {Information and Software Technology},
  volume    = {55},
  number    = {8},
  year      = {2013},
  pages     = {1374--1396},
  url = {http://www.ece.ubc.ca/~amesbah/docs/ist13.pdf},
}


@inproceedings{shabnam:mutandis,
	author = {Shabnam Mirshokraie and Ali Mesbah and Karthik Pattabiraman},
	title = {Efficient JavaScript Mutation Testing},
	booktitle = {Proceedings of the International Conference on Software Testing, Verification and Validation (ICST)}, 
	publisher = {IEEE Computer Society},
	year = {2013},
	pages = {74--83},
	url = {http://ece.ubc.ca/~amesbah/docs/icst13.pdf},
    slides = {40727518},   
    award = {[Best Paper Runner-up Award]}
}

@inproceedings{jana:icwe13,
	author = {Zahra Behfarshad and Ali Mesbah},
	title = {Hidden-Web Induced by Client-Side Scripting: An Empirical Study},
  booktitle = {Proceedings of the International Conference on Web Engineering (ICWE)},
  year = {2013}, 
  volume    = {7977},
  publisher = {Springer},
  pages     = {52--67},
  url = {http://www.ece.ubc.ca/~amesbah/docs/icwe13.pdf},
  slides = {40727637},
  award = {[Best Paper Award]},
  abstract = {Client-side JavaScript is increasingly used for enhancing web application functionality, interactivity, and responsiveness. Through the execution of JavaScript code in browsers, the DOM tree representing a webpage at runtime, can be incrementally updated without requiring a URL change. This dynamically updated content is hidden from general search engines. In this paper, we present the first empirical study on measuring and characterizing the hidden-web induced as a result of client-side JavaScript execution. Our study reveals that this type of hidden-web content is prevalent in online web applications today: from the 500 websites we analyzed, 95\% contain client-side hidden-web content; On those websites that contain client-side hidden-web content, (1) on average, 62\% of the web states are hidden, (2) per hidden state, there is an average of 19 kilobytes of data that is hidden from which 0.6 kilobytes contain textual content, (3) the DIV element is the most common clickable element used (61\%) to initiate this type of hidden-web state transition, and (4) on average 25 minutes is required to dynamically crawl 50 DOM states. Further, our study indicates that there is a correlation between DOM tree size and hidden-web content, but no correlation exists between the amount of JavaScript code and client-side hidden-web.}
}


@inproceedings{james:imagen,
        author = {James Lo and Eric Wohlstadter and Ali Mesbah},
        title = {Imagen: Runtime Migration of Browser Sessions for JavaScript Web Applications},
        booktitle = {Proceedings of the International World Wide Web Conference (WWW)},
        publisher = {ACM},
        pages = {815--825},
        year = {2013},
        url = {http://ece.ubc.ca/~amesbah/docs/www13.pdf},
        note = {[Acceptance rate 15%]}
}

@inproceedings{mona:esem13,
	author = {Erfani Joorabchi, Mona and Ali Mesbah and Philippe Kruchten},
	title = {Real Challenges in Mobile App Development},
	booktitle = {Proceedings of the ACM/IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM)},
	year = {2013}, 
	publisher = {IEEE Computer Society},
	pages = {15--24},
	url = {http://www.ece.ubc.ca/~amesbah/docs/mona-esem13.pdf},
	abstract = {Context: Mobile app development is a relatively new phenomenon that is increasing rapidly due to the ubiquity and popularity of smartphones among end-users. Objective: The goal of our study is to gain an understanding of the main challenges developers face in practice when they build apps for different mobile devices. Method: We conducted a qualitative study, following a Grounded Theory approach, in which we interviewed 12
senior mobile developers from 9 different companies, followed by a semi-structured survey, with 188 respondents from the mobile development community. Results: The outcome is an overview of the current challenges faced by mobile developers in practice, such as developing apps across multiple platforms, lack of robust monitoring, analysis, and testing tools, and emulators that are slow or miss many features of mobile devices. Conclusion: Based
on our findings of the current practices and challenges, we highlight areas that require more attention from the research and development community.}
}

@inproceedings{frolin:jsbugs,
        author = {Frolin Ocariza and Kartik Bajaj and Karthik Pattabiraman and Ali Mesbah},
        title = {An Empirical Study of Client-Side JavaScript Bugs},
        booktitle = {Proceedings of the ACM/IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM)},
        publisher = {IEEE Computer Society},
        pages = {55--64},
        year = {2013},
        url = {http://www.ece.ubc.ca/~amesbah/docs/frolin-esem13.pdf},
        abstract = {Context: Client-side JavaScript is widely used in web applications to improve user-interactivity and minimize client-server communications. Unfortunately, web applications are prone to JavaScript faults. While prior studies have demonstrated the prevalence of these faults, no attempts have been made to determine their root causes and consequences. Objective: The goal of our study is to understand the root causes and impact of JavaScript faults and how the results can impact JavaScript programmers, testers and tool developers. Method: We perform an empirical study of 317 bug reports from 12 bug repositories. The bug reports are thoroughly examined to classify and extract information about the fault's cause (the error) and consequence (the failure and impact). Result: The majority (65\%) of JavaScript faults are DOM-related, meaning they are caused by faulty interactions of the JavaScript
code with the Document Object Model (DOM). Further, 80\% of
the highest impact JavaScript faults are DOM-related. Finally, most JavaScript faults originate from programmer mistakes committed in the JavaScript code itself, as opposed to other web application components such as the server-side or HTML code. Conclusion: Given the prevalence of DOM-related faults, JavaScript programmers need development tools that can help them reason about the DOM. Also, testers should prioritize detection of DOM-related faults as most high impact faults belong to this category. Finally, developers can use the error patterns we found to design more powerful static analysis tools for JavaScript.}
}

@inproceedings{amin:scam13,
        author = {Milani Fard, Amin and Ali Mesbah},
        title = {JSNose: Detecting JavaScript Code Smells},
        booktitle = {Proceedings of the International Conference on Source Code Analysis and Manipulation (SCAM)},
        publisher = {IEEE Computer Society},
        pages={116--125}, 
        year = {2013},
        url = {http://www.ece.ubc.ca/~amesbah/docs/scam13.pdf},
        abstract = {JavaScript is a powerful and flexible prototype-based scripting language that is increasingly used by developers to create interactive web applications. The language is interpreted, dynamic, weakly-typed, and has first-class functions. In addition, it interacts with other web languages such as CSS and HTML at runtime. All these characteristics make JavaScript code particularly error-prone and challenging to write and maintain. Code smells are patterns in the source code that can adversely influence program comprehension and maintainability of the program in the long term. We propose a set of 13 JavaScript code smells, collected from various developer resources. We present a JavaScript code smell detection technique called JSNose. Our metric-based approach combines static and dynamic analysis to detect smells in client-side code. This automated technique can help developers to spot code that could benefit from refactoring. We evaluate the smell finding capabilities of our technique through an empirical study. By analyzing 11 web applications, we investigate which smells detected by JSNose are more prevalent.}
}

@inproceedings{shabnam:ase13,
	author = {Shabnam Mirshokraie and Ali Mesbah and Karthik Pattabiraman},
	title = {Pythia: Generating Test Cases with Oracles for JavaScript Applications},
	booktitle = {Proceedings of the ACM/IEEE International Conference on Automated Software Engineering (ASE), New Ideas Track}, 
	publisher = {IEEE Computer Society},
	year = {2013},
	pages = {610--615},
	 url = {http://salt.ece.ubc.ca/publications/docs/ase13.pdf}
}

@inproceedings{amin:issre13,
        author = {Milani Fard, Amin and Ali Mesbah},
        title = {Feedback-directed Exploration of Web Applications to Derive Test Models},
        booktitle = {Proceedings of the International Symposium on Software Reliability Engineering (ISSRE)},
        publisher = {IEEE Computer Society},
        pages = {278--287},
        year = {2013},
        url = {http://www.ece.ubc.ca/~amesbah/docs/issre13.pdf},
        abstract = {Dynamic exploration techniques play a significant role in automated web application testing and analysis. However,
a general web application crawler that exhaustively explores
the states can become mired in limited specific regions of
the web application, yielding poor functionality coverage. In
this paper, we propose a feedback-directed web application
exploration technique to derive test models. While exploring,
our approach dynamically measures and applies a combination
of code coverage impact, navigational diversity, and structural
diversity, to decide a-priori (1) which state should be expanded,
and (2) which event should be exercised next to maximize the
overall coverage, while minimizing the size of the test model.
Our approach is implemented in a tool called FeedEx. We
have empirically evaluated the efficacy of FeedEx using six web
applications. The results show that our technique is successful in
yielding higher coverage while reducing the size of the test model,
compared to classical exhaustive techniques such as depth-first,
breadth-first, and random exploration.}
}


@inproceedings{kartik:msr14,
        author = {Kartik Bajaj and Karthik Pattabiraman and Ali Mesbah},
        title = {Mining Questions Asked by Web Developers},
        booktitle = {Proceedings of the Working Conference on Mining Software Repositories (MSR)},
        publisher = {ACM},
        pages = {112--121},
        year = {2014},
    	url = {http://salt.ece.ubc.ca/publications/docs/kartik-msr14.pdf},
    	slides = {40727407},	
    abstract = {Modern web applications consist of a significant amount of client-side code, written in JavaScript, HTML, and CSS. In this paper, we present a study of common challenges and misconceptions among web developers, by mining related questions asked on Stack Overflow. We use unsupervised learning to categorize the mined questions and define a ranking algorithm to rank all the Stack Overflow questions based on their importance. We analyze the top 50 questions qualitatively. The results indicate that (1) the overall share of web development related discussions is increasing among developers, (2) browser related discussions are prevalent; however, this share is decreasing with time, (3) form validation and other DOM related discussions have been discussed consistently over time, (4) web related discussions are becoming more prevalent in mobile development, and (5) developers face implementation issues with new HTML5 features such as Canvas. We examine the implications of the results on the development, research, and standardization communities.}        
}

@inproceedings{mona:msr14,
	author = {Erfani Joorabchi, Mona and Mehdi Mirzaaghaei and Ali Mesbah},
	title = {Works For Me! {C}haracterizing Non-Reproducible Bug Reports},
    booktitle = {Proceedings of the Working Conference on Mining Software Repositories (MSR)}, 
	publisher = {ACM},
	pages = {62--71},
    year = {2014},
    url = {http://salt.ece.ubc.ca/publications/docs/mona-msr14.pdf},    
    slides = {40727387},
    abstract = {Bug repository systems have become an integral component of software development activities. Ideally, each bug report should help developers to find and fix a software fault. However, there is a subset of reported bugs that is not (easily) reproducible, on which developers spend considerable amounts of time and effort. We present an empirical analysis of non- reproducible bug reports to characterize their rate, nature, and root causes. We mine one industrial and five open-source bug repositories, resulting in 32K non-reproducible bug reports. We (1) compare properties of non-reproducible reports with their counterparts such as active time and number of authors, (2) investigate their life-cycle patterns, and (3) examine 120 Fixed non-reproducible reports. In addition, we qualitatively classify a set of randomly selected non-reproducible bug reports (1,643) into six common categories. Our results show that, on average, non-reproducible bug reports pertain to 17\% of all bug reports, remain active three months longer than their counterparts, can be mainly (45\%) classified as "Interbug Dependencies", and 66\% of Fixed non-reproducible reports were indeed reproduced and fixed.}
}

@inproceedings{icse14seip,
	author = {Alex Nederlof and Ali Mesbah and van Deursen, Arie},
	title = {Software Engineering for the Web: The State of the Practice},
  booktitle = {Proceedings of the ACM/IEEE International Conference on Software Engineering, Software Engineering In Practice (ICSE SEIP)},
  publisher = {ACM},
  pages = {4--13},
  year = {2014},
  url = {http://salt.ece.ubc.ca/publications/docs/icse14-seip.pdf},
  slides = {35488525},
  abstract = {Today's web applications increasingly rely on client-side code execution. HTML is not just created on the server, but manipulated extensively within the browser through JavaScript code. In this paper, we seek to understand the software engineering implications of this. We look at deviations from many known best practices in such areas of performance, accessibility, and correct structuring of HTML documents. Furthermore, we assess to what extent such deviations manifest themselves through client-side code manipulation only. To answer these questions, we conducted a large scale experiment, involving automated client-enabled crawling of over 4000 web applications, resulting in over 100,000,000 pages analyzed, and close to 1,000,000 unique client-side user interface states. Our findings show that the majority of sites contain a substantial number of problems, making sites unnecessarily slow, inaccessible for the visually impaired, and with layout that is unpredictable due to errors in the dynamically modified DOM trees.}
}

@inproceedings{frolin:vejovis,
    author = {Frolin Ocariza and Karthik Pattabiraman and Ali Mesbah},
    title = {Vejovis: Suggesting Fixes for JavaScript Faults},
    booktitle = {Proceedings of the ACM/IEEE International Conference on Software Engineering (ICSE)},
    publisher = {ACM},
    pages = {837--847},
    year = {2014},
    url = {http://salt.ece.ubc.ca/publications/docs/vejovis-icse14.pdf},
	slides = {40727306},
    abstract = {JavaScript is used in web applications for achieving rich user interfaces and implementing core functionality. Unfortunately, JavaScript code is known to be prone to faults. In an earlier study, we found that over 65\% of such faults are caused by the interaction of JavaScript code with the DOM at runtime (DOM-related faults). In this paper, we first perform an analysis of 190 bug reports to understand fixes commonly applied by programmers to these DOM- related faults; we observe that parameter replacements and DOM element validations are common fix categories. Based on these findings, we propose an automated technique and tool, called Vejovis, for suggesting repairs for DOM-based JavaScript faults. To evaluate Vejovis, we conduct a case study in which we subject Vejovis to 22 real-world bugs across 11 applications. We find that Vejovis accurately suggests repairs for 20 out of the 22 bugs, and in 13 of the 20 cases, the correct fix was the top ranked one.}
}

@inproceedings{saba:clematis,
        author = {Saba Alimadadi and Sheldon Sequeira and Ali Mesbah and Karthik Pattabiraman},
        title = {Understanding JavaScript Event-based Interactions},
        booktitle = {Proceedings of the ACM/IEEE International Conference on Software Engineering (ICSE)},
        publisher = {ACM},
        pages = {367--377},
        url = {http://salt.ece.ubc.ca/publications/docs/clematis-icse14.pdf},
        report = {http://salt.ece.ubc.ca/publications/docs/UBC-SALT-2014-001.pdf},
        year = {2014},
        slides = {40727246},
        tool = {https://github.com/saltlab/clematis},
        award= {[ACM SIGSOFT Distinguished Paper Award]},
        abstract = {Web applications have become one of the fastest growing types of software systems today. Despite their popularity, understanding the behaviour of modern web applications is still a challenging endeavour for developers during development and maintenance tasks. The challenges mainly stem from the dynamic, event-driven, and asynchronous nature of the JavaScript language. We propose a generic technique for capturing low-level event-based interactions in a web application and mapping those to a higher-level behavioural model. This model is then transformed into an interactive visualization, representing episodes of triggered causal and temporal events, related JavaScript code executions, and their impact on the dynamic DOM state. Our approach, implemented in a tool called Clematis, allows developers to easily understand the complex dynamic behaviour of their application at three different semantic levels of granularity. The results of our industrial controlled experiment show that Clematis is capable of improving the task accuracy by 61\%, while reducing the task completion time by 47\%.}
}

@inproceedings{domcovery:issta14,
	author = {Mehdi Mirzaaghaei and Ali Mesbah},
	title = {DOM-based Test Adequacy Criteria for Web Applications},
    booktitle = {Proceedings of the International Symposium on Software Testing and Analysis (ISSTA)},
    publisher = {ACM},
    pages = {71--81},
    url = {http://salt.ece.ubc.ca/publications/docs/issta14.pdf},
    slides = {40727046},
    year = {2014},
    abstract = {To assess the quality of web application test cases, web developers currently measure code coverage. Although code coverage has traditionally been a popular test adequacy criterion, we believe it alone is not adequate for assessing the quality of web application test cases. We propose a set of novel DOM-based test adequacy criteria for web applications. These criteria aim at measuring coverage at two granularity levels, (1) the percentage of DOM states and transitions covered in the total state space of the web application under test, and (2) the percentage of elements covered in each particular DOM state. We present a technique and tool, called DomCovery, which automatically extracts and measures the proposed adequacy criteria and generates a visual DOM coverage report. Our evaluation shows that there is no correlation between code coverage and DOM coverage. A controlled experiment illustrates that participants using DOMCovery completed coverage related tasks 22 percent more accurately and 66 percent faster.}
}

@inproceedings{css:refactoring,
	author = {Davood Mazinanian and Nikolaos Tsantalis and Ali Mesbah},
	title = {Discovering Refactoring Opportunities in Cascading Style Sheets},
    booktitle = {Proceedings of the ACM SIGSOFT International Symposium on the Foundations of Software Engineering (FSE)},
    publisher = {ACM},
    pages = {496--506},
    year = {2014},
    url = {http://salt.ece.ubc.ca/publications/docs/fse14.pdf},
    abstract = {Cascading Style Sheets (CSS) is a language used for describing the look and formatting of HTML documents. CSS has been widely adopted in web and mobile development practice, since it enables a clean separation of content from presentation. The language exhibits complex features, such as inheritance, cascading and specificity, which make CSS code hard to maintain. Therefore, it is important to find ways to improve the maintainability of CSS code. In this paper, we propose an automated approach to remove duplication in CSS code. More specifically, we have developed a technique that detects three types of CSS declaration duplication and recommends refactoring opportunities to eliminate those duplications. Our approach uses preconditions that ensure the application of a refactoring will preserve the original document styling. We evaluate our technique on 38 real-world web systems and 91 CSS files, in total. Our findings show that duplication in CSS code is widely prevalent. Additionally, there is a significant number of presentation-preserving refactoring opportunities that can reduce the size of the CSS files and increase the maintainability of the code.}
}

@inproceedings{kartik:ase14,
        author = {Kartik Bajaj and Karthik Pattabiraman and Ali Mesbah},
        title = {Dompletion: DOM-Aware JavaScript Code Completion},
        booktitle = {Proceedings of the IEEE/ACM International Conference on Automated Software Engineering (ASE)},
        publisher = {ACM},
        pages = {43--54},
        year = {2014},
        url = {http://salt.ece.ubc.ca/publications/docs/dompletion-ase14.pdf},
        report = {http://salt.ece.ubc.ca/publications/docs/UBC-SALT-2014-002.pdf},
        slides = {39264734},
        abstract = {JavaScript is a scripting language that plays a prominent role in modern web applications. It is dynamic in nature and interacts heavily with the Document Object Model (DOM) at runtime. These characteristics make providing code completion support to JavaScript programmers particularly challenging. We propose an automated technique that reasons about existing DOM structures, dynamically analyzes the JavaScript code, and provides code completion suggestions for JavaScript code that interacts with the DOM through its APIs. Our automated code completion scheme is implemented in an open source tool called Dompletion. The results of our empirical evaluation indicate that (1) DOM structures exhibit patterns, which can be extracted and reasoned about in the context of code completion suggestions; (2) Dompletion can provide code completion suggestions with a recall of 89 precent, precision of 90 precent, and an average time of 2.8 seconds.}

}

@inproceedings{amin:ase14,
	author = {Milani Fard, Amin and Mehdi Mirzaaghaei and Ali Mesbah},
	title = {Leveraging Existing Tests in Automated Test Generation for Web Applications},
        booktitle = {Proceedings of the IEEE/ACM International Conference on Automated Software Engineering (ASE)},
        publisher = {ACM},
        pages = {67--78},
        year = {2014},   
        url = {http://salt.ece.ubc.ca/publications/docs/testilizer-ase14.pdf},
        slides = {39262904},
        abstract = {To test web applications, developers currently write test cases in frameworks such as Selenium. On the other hand, most web test generation techniques rely on a crawler to explore the dynamic states of the application. The first approach requires much manual effort, but benefits from the domain knowledge of the developer writing the test cases. The second one is automated and systematic, but lacks the domain knowledge required to be as effective. We believe combining the two can be advantageous. In this paper, we propose to (1) mine the human knowledge present in the form of input values, event sequences, and assertions, in the human-written test suites, (2) combine that inferred knowledge with the power of automated crawling, and (3) extend the test suite for uncovered/unchecked portions of the web application under test. Our approach is implemented in a tool called Testilizer. An evaluation of our approach indicates that Testilizer (1) outperforms a random test generator, and (2) on average, can generate test suites with improvements of up to 150 percent in fault detection rate and up to 30 precent in code coverage, compared to the original test suite.}
}

@article{vanDeursen2014,
  title = {Crawl-based analysis of web applications: Prospects and challenges},
  journal = {Science of Computer Programming},
  volume = {97, Part 1},
  pages = {173--180},
  year = {2015},
  doi = {http://dx.doi.org/10.1016/j.scico.2014.09.005},
  url = {http://www.sciencedirect.com/science/article/pii/S0167642314003815},
  author = {van Deursen, Arie and Ali Mesbah and Alex Nederlof},
    abstract = {In this paper we review five years of research in the field of automated crawling and testing of web applications. We describe the open source Crawljax tool, and the various extensions that have been proposed in order to address such issues as cross-browser compatibility testing, web application regression testing, and style sheet usage analysis. Based on that we identify the main challenges and future directions of crawl-based testing of web applications. In particular, we explore ways to reduce the exponential growth of the state space, as well as ways to involve the human tester in the loop, thus reconciling manual exploratory testing and automated test input generation. Finally, we sketch the future of crawl-based testing in the light of upcoming developments, such as the pervasive use of touch devices and mobile computing, and the increasing importance of cyber-security.}
}

@ARTICLE{shabnam:tse13,
  author = {Shabnam Mirshokraie  and Ali Mesbah and Karthik Pattabiraman},
  title = {Guided Mutation Testing for JavaScript Web Applications},
  journal = {IEEE Transactions on Software Engineering (TSE)},
  year = {2015},
  volume={41}, 
  number={5}, 
  pages={429--444},   
  url = {http://salt.ece.ubc.ca/publications/docs/mutandis-tse.pdf},
}

@inproceedings{frolin:icse15,
  author = {Frolin Ocariza and Karthik Pattabiraman and Ali Mesbah},
  title = {Detecting Inconsistencies in {JavaScript} {MVC} Applications},
  booktitle = {Proceedings of the ACM/IEEE International Conference on Software Engineering (ICSE)},
  publisher = {ACM},
  pages = {325--335},
  year = {2015},
  url = {http://salt.ece.ubc.ca/publications/docs/icse15.pdf},
}

@inproceedings{shabnam:icst15,
	author = {Shabnam Mirshokraie and Ali Mesbah and Karthik Pattabiraman},
	title = {JSEFT: Automated {JavaScript} Unit Test Generation},
        booktitle = {Proceedings of the International Conference on Software Testing, Verification and Validation (ICST)},
        publisher = {IEEE Computer Society},
        pages = {10 pages},
        year = {2015},
        url = {http://salt.ece.ubc.ca/publications/docs/icst15.pdf},
        abstract = {The event-driven and highly dynamic nature of JavaScript, as well as its runtime interaction with the Document Object Model (DOM) make it challenging to test JavaScript-based applications. Current web test automation techniques target the generation of event sequences, but they ignore testing the JavaScript code at the unit level. Further they either ignore the oracle problem completely or simplify it through generic soft oracles such as HTML validation and runtime exceptions. We present a framework to automatically generate test cases for JavaScript applications at two complementary levels, namely events and individual JavaScript functions. Our approach employs a combination of function coverage maximization and function state abstraction algorithms to efficiently generate test cases. In addition, these test cases are strengthened by automatically generated mutation-based oracles. We empirically evaluate the implementation of our approach, called JSeft, to assess its efficacy. The results, on 13 JavaScript-based applications, show that the generated test cases achieve a coverage of 68 percent and that JSeft can detect injected JavaScript and DOM faults with a high accuracy (100 percent precision, 70 percent recall). We also find that JSeft outperforms an existing JavaScript test automation framework both in terms of coverage and detected faults.}
}

@inbook{mesbah:advances15,
  author = {Ali Mesbah},
  title = {Advances in Testing {JavaScript}-based Web Applications},
  chapter = {5},
  publisher = {Elsevier},
  year = {2015},
  volume = {97},
  pages = {201--235},
  series = {Advances in Computers},
  issn = {0065-2458},
  url = {http://www.sciencedirect.com/science/article/pii/S0065245814000114},
}

@ARTICLE{stvr15-frolin,
  author = {Frolin Ocariza and Guanpeng Li and Karthik Pattabiraman and Ali Mesbah},
  title = {Automatic Fault Localization for Client-Side {JavaScript}},
  journal = {Journal of Software Testing, Verification and Reliability (STVR)},
  year = {2015},
  pages={20 pages}, 
  publisher = {Wiley},
  url = {http://salt.ece.ubc.ca/publications/docs/stvr15-frolin.pdf},
  abstract = {JavaScript is a scripting language that plays a prominent role in web applications today. It is dynamic, loosely typed and asynchronous and is extensively used to interact with the Document Object Model (DOM) at runtime. All these characteristics make JavaScript code error-prone; unfortunately, JavaScript fault localization remains a tedious and mainly manual task. Despite these challenges, the problem has received very limited research attention. This paper proposes an automated technique to localize JavaScript faults based on dynamic analysis, tracing and backward slicing of JavaScript code. This technique is capable of handling features of JavaScript code that have traditionally been difficult to analyze, including eval, anonymous functions and minified code. The approach is implemented in an open source tool called AutoFlox, and evaluation results indicate that it is capable of (1) automatically localizing DOM-related JavaScript faults with high accuracy (over 96\%) and no false-positives and (2) isolating JavaScript faults in production websites and actual bugs from real-world web applications.}
}


@inproceedings{ecoop15,
    author = {Saba Alimadadi and Ali Mesbah and Karthik Pattabiraman},
    title = {Hybrid {DOM}-Sensitive Change Impact Analysis for {JavaScript}},
    booktitle = {Proceedings of the European Conference on Object-Oriented Programming (ECOOP)},
    publisher = {LIPIcs},
    pages = {321--345},
    year = {2015},
    url = {http://salt.ece.ubc.ca/publications/docs/ecoop15.pdf},
    abstract = {JavaScript has grown to be among the most popular programming languages. However, performing change impact analysis on JavaScript applications is challenging due to features such as the seamless interplay with the DOM, event-driven and dynamic function calls, and asynchronous client/server communication. We first perform an empirical study of change propagation, the results of which show that the DOM-related and dynamic features of JavaScript need to be taken into consideration in the analysis since they affect change impact propagation. We propose a DOM-sensitive hybrid change impact analysis technique for JavaScript through a combination of static and dynamic analysis. The proposed approach incorporates a novel ranking algorithm for indicating the importance of each entity in the impact set. Our approach is implemented in a tool called Tochal. The results of our evaluation reveal that Tochal provides a more complete analysis compared to static or dynamic methods. Moreover, through an industrial controlled experiment, we find that Tochal helps developers by improving their task completion duration by 78\% and accuracy by 223\%.},
    youtube = {7DsSxmTfgDY}
}

@inproceedings{fse15,
        author = {Yucheng Zhang and Ali Mesbah},
        title = {Assertions Are Strongly Correlated with Test Suite Effectiveness},
        booktitle = {Proceedings of the joint meeting of the European Software Engineering Conference and the ACM SIGSOFT Symposium on the Foundations of Software Engineering (ESEC/FSE)},
        publisher = {ACM},
        pages = {214--224},
        year = {2015},
        url = {http://salt.ece.ubc.ca/publications/docs/fse15.pdf},
        abstract = {Code coverage is a popular test adequacy criterion in practice. Code coverage, however, remains controversial as there is a lack of coherent empirical evidence for its relation with test suite effectiveness. More recently, test suite size has been shown to be highly correlated with effectiveness. However, previous studies treat test methods as the smallest unit of interest, and ignore potential factors influencing this relationship. We propose to go beyond test suite size, by investigating test assertions inside test methods. We empirically evaluate the relationship between a test suite?s effectiveness and the (1) number of assertions, (2) assertion coverage, and (3) different types of assertions. We compose 6,700 test suites in total, using 24,000 assertions of five real-world Java projects. We find that the number of assertions in a test suite strongly correlates with its effectiveness, and this factor directly influences the relationship between test suite size and effectiveness. Our results also indicate that assertion coverage is strongly correlated with effectiveness and different types of assertions can influence the effectiveness of their containing test suites.}
}

@inproceedings{icsme15,
        author = {Arash Vahabzadeh and Milani Fard, Amin and Ali Mesbah},
        title = {An Empirical Study of Bugs in Test Code},
        booktitle = {Proceedings of the International Conference on Software Maintenance and Evolution (ICSME)},
        publisher = {IEEE Computer Society},
        pages = {10 pages},
        year = {2015},
        abstract = {Unit testing aims at detecting (regression) bugs in production code. However, testing code is just as likely to contain bugs as the code it tests. Buggy test cases can silently miss bugs in the production code or loudly ring false alarms when the production code is correct. We present the first empirical study of bugs in test code to characterize their prevalence and root cause categories. We mine the bug repositories and version control systems of 211 Apache Software Foundation (ASF) projects and find 5,556 test-related bug reports. We (1) compare properties of test bugs with production bugs, such as active time and fixing effort needed, (2) qualitatively study 443 randomly sampled test bug reports in detail and categorize them based on their impact and root causes, (3) run FindBugs on the test code of the latest version of the projects to discover potential (undiscovered) bugs. Our results show that (1) around half of all the projects had bugs in their test code; (2) the majority of test bugs are false alarms, i.e., test fails while the production code is correct, while a minority of these bugs result in silent horrors, i.e., test passes while the production code is incorrect; (3) incorrect and missing assertions are the dominant root cause of silent horror bugs; (4) semantic (25\%), flaky (21\%), environment-related (18\%) bugs are the dominant root cause categories of false alarms; (5) the majority of false alarm bugs happen in the exercise portion of the tests, and (6) developers contribute more actively to fixing test bugs and test bugs are fixed sooner compared to production bugs.},
        url = {http://salt.ece.ubc.ca/publications/docs/icsme15.pdf},

}

@inproceedings{esem15,
        author = {Keheliya Gallaba and Ali Mesbah and Ivan Beschastnikh},
        title = {Don't Call Us, We'll Call You: Characterizing Callbacks in {JavaScript}},
        booktitle = {Proceedings of the ACM/IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM)},
        publisher = {IEEE Computer Society},
        pages = {10 pages},
        year = {2015},
        abstract = {JavaScript is a popular language for developing web applications and is increasingly used for both client-side and server-side application logic. The JavaScript runtime is inherently event-driven and callbacks are a key language feature. Unfortunately, callbacks induce a non-linear control flow and can be deferred to execute asynchronously, declared anonymously, and may be nested to arbitrary levels. All of these features make callbacks difficult to understand and maintain. We perform an empirical study to characterize JavaScript callback usage across a representative corpus of 138 JavaScript programs, with over 5 million lines of JavaScript code. We find that on average, every 10th function definition takes a callback argument, and that over 43\% of all callback-accepting function callsites are anonymous. Furthermore, the majority of callbacks are nested, more than half of all callbacks are asynchronous, and asynchronous callbacks, on average, appear more frequently in client-side code (72\%) than server-side (55\%). We also study three well-known solutions designed to help with the complexities associated with callbacks, including the error-first callback convention, Async.js library, and Promises. Our results inform the design of future JavaScript analysis and code comprehension tools.},
       url = {http://salt.ece.ubc.ca/callback-study/esem15-js-callbacks-study.pdf}
}

@inproceedings{kartik:ase15,
        author = {Kartik Bajaj and Karthik Pattabiraman and Ali Mesbah},
        title = {Synthesizing Web Element Locators},
        booktitle = {Proceedings of the IEEE/ACM International Conference on Automated Software Engineering (ASE)},
        publisher = {IEEE Computer Society},
        pages = {11 pages},
        year = {2015},
       url = {http://salt.ece.ubc.ca/publications/docs/ase15-led.pdf},
       abstract = {To programmatically interact with the user interface of a web application, element locators are used to select and retrieve elements from the Document Object Model (DOM). Element locators are used in JavaScript code, Cascading stylesheets, and test cases to interact with the runtime DOM of the webpage. Constructing these element locators is, however, challenging due to the dynamic nature of the DOM. We find that locators written by web developers can be quite complex, and involve selecting multiple DOM elements. We present an automated technique for synthesizing DOM element locators using examples provided interactively by the developer. The main insight in our approach is that the problem of synthesizing complex multi-element locators can be expressed as a constraint solving problem over the domain of valid DOM states in a web application. We implemented our synthesis technique in a tool called LED, which provides an interactive drag and drop support inside the browser for selecting positive and negative examples. We find that LED supports at least 86\% of the locators used in the JavaScript code of deployed web applications, and that the locators synthesized by LED have a recall of 98\% and a precision of 63\%. LED is fast, taking only 0.23 seconds on average to synthesize a locator.}
        
}

@inproceedings{amin:ase15,
        author = {Amin Milani Fard and Ali Mesbah and Eric Wohlstadter},
        title = {Generating Fixtures for {JavaScript} Unit Testing},
        booktitle = {Proceedings of the IEEE/ACM International Conference on Automated Software Engineering (ASE)},
        publisher = {IEEE Computer Society},
        pages = {11 pages},
        year = {2015},
        abstract = {In today's web applications, JavaScript code interacts with the Document Object Model (DOM) at runtime. This runtime interaction between JavaScript and the DOM is error-prone and challenging to test. In order to unit test a JavaScript function that has read/write DOM operations, a DOM instance has to be provided as a test fixture. This DOM fixture needs to be in the exact structure expected by the function under test. Otherwise, the test case can terminate prematurely due to a null exception. Generating these fixtures is challenging due to the dynamic nature of JavaScript and the hierarchical structure of the DOM. We present an automated technique, based on dynamic symbolic execution, which generates test fixtures for unit testing JavaScript functions. Our approach is implemented in a tool called Confix. Our empirical evaluation shows that Confix can effectively generate tests that cover DOM-dependent paths. We also find that Confix yields considerably higher coverage compared to an existing JavaScript input generation technique.},
         url = {http://salt.ece.ubc.ca/publications/docs/ase15-confix.pdf},
}

@inproceedings{issre15,
	author = {Erfani Joorabchi, Mona and Mohamed Ali and Ali Mesbah},
	title = {Detecting Inconsistencies in Multi-Platform Mobile Apps},
	booktitle = {Proceedings of the International Symposium on Software Reliability Engineering (ISSRE)},
	publisher = {IEEE Computer Society},
	pages = {11 pages},
	year = {2015},	
}
